local GOAL_BLOCK_NAME = "minecraft:yellow_concrete"
local DELAY_SECONDS = 0.2 

local x = 0
local y = 0
local dir = 0 -- 0=North (+y), 1=East (+x), 2=South (-y), 3=West (-x)
local visited = {} 
local path_stack = {} 


local function check_goal()
    local success, block_data = turtle.inspectDown()
    
    if success and block_data and block_data.name == GOAL_BLOCK_NAME then
        print("GOAL: SUCCESS! Standing on the '" .. GOAL_BLOCK_NAME .. "' block.")
        return true
    end
    return false
end

local function check_fuel()
    if turtle.getFuelLevel() == 0 then
        print("FUEL: Low or empty! Attempting to refuel...")
        -- Assumes fuel item is in slot 1
        local success, reason = turtle.refuel(1) 
        if success then
            print("FUEL: Refuel successful. Current fuel: " .. turtle.getFuelLevel())
        else
            print("ERROR: Refuel failed. Reason: " .. (reason or "Unknown"))
            print("ACTION: Halting. Please ensure fuel is in slot 1.")
            return false -- Stops the program on critical failure (no fuel and can't refuel)
        end
    end
    return true
end

local function mark_visited()
    visited[x] = visited[x] or {}
    visited[x][y] = true
end

local function is_visited(px, py)
    return visited[px] and visited[px][py]
end

local function get_next_coords(direction_index, cx, cy)
    local px, py = cx, cy
    if direction_index == 0 then py = py + 1 -- North
    elseif direction_index == 1 then px = px + 1 -- East
    elseif direction_index == 2 then py = py - 1 -- South
    elseif direction_index == 3 then px = px - 1 end -- West
    return px, py
end

local function move_forward()
    if turtle.forward() then
        x, y = get_next_coords(dir, x, y)
        table.insert(path_stack, {x = x, y = y}) -- Pushes current location to stack
        mark_visited()
        return true
    end
    return false
end

local function turn_to(new_dir)
    local turns = (new_dir - dir + 4) % 4
    if turns == 1 then
        turtle.turnRight()
    elseif turns == 2 then
        turtle.turnRight()
        turtle.turnRight()
    elseif turns == 3 then
        turtle.turnLeft()
    end
    dir = new_dir
end


local function explore_and_move()
    local current_x, current_y = x, y
    
    local relative_directions = {1, 0, 3, 2} 
    
    for i, rel_dir in ipairs(relative_directions) do
        local check_dir = (dir + rel_dir) % 4
        
        local px, py = get_next_coords(check_dir, current_x, current_y)

        turn_to(check_dir) 
        
        if not turtle.detect() then
            if not is_visited(px, py) then
                -- FOUND: Unvisited path. TAKE IT and push to stack (Depth-First Search).
                print("EXPLORE: New path found. Priority: " .. rel_dir)
                move_forward()
                return -- Successful exploration move
            end
        end
    end
    
    if #path_stack > 1 then
        print("DEAD END: Retracing steps to find an unexplored fork.")
        
        table.remove(path_stack)
        
        local last_point = path_stack[#path_stack] 
        
        local dx = last_point.x - x
        local dy = last_point.y - y
        
        local backtrack_dir = dir
        if dx == 1 then backtrack_dir = 1 -- East
        elseif dx == -1 then backtrack_dir = 3 -- West
        elseif dy == 1 then backtrack_dir = 0 -- North
        elseif dy == -1 then backtrack_dir = 2 end -- South

        turn_to(backtrack_dir)
        turtle.forward()

        x, y = last_point.x, last_point.y
        
    elseif #path_stack == 1 then
  
        print("IDLING: Back at start (0, 0). Fully explored. Performing 360 scan.")
        turtle.turnRight() 
        sleep(0.1)
        turtle.turnRight()
        sleep(0.1)
        turtle.turnRight()
        sleep(0.1)
        turtle.turnRight()
    end
end


print("--- Starting Unstoppable Exhaustive Maze Solver (DFS) ---")
print("INFO: Target Goal Block is: " .. GOAL_BLOCK_NAME)
print("INFO: Program will run until the Yellow Concrete is found.")

mark_visited()
table.insert(path_stack, {x = x, y = y})

while not check_goal() do
    if not check_fuel() then
        break 
    end

    explore_and_move()

    sleep(DELAY_SECONDS)
end

if check_goal() then
    print("--- Maze Solver Program Finished: GOAL REACHED ---")
else
    -- Only reached if check_fuel() failed.
    print("--- Maze Solver Program Halted: Fuel depletion or unexpected error. ---")
end
